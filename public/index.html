<script>
    let selectedFiles = {};
    const API_BASE = '/api'; // Vercel serverless functions

    // Initialize drag and drop for all file inputs
    document.addEventListener('DOMContentLoaded', function() {
        initializeDragAndDrop();
        showNotification('Ready! Client-side processing uses your CPU, server-side uses Vercel.', 'info');
    });

    function initializeDragAndDrop() {
        const fileInputs = document.querySelectorAll('.file-input');
        
        fileInputs.forEach(input => {
            input.addEventListener('dragover', (e) => {
                e.preventDefault();
                input.classList.add('dragover');
            });
            
            input.addEventListener('dragleave', (e) => {
                e.preventDefault();
                input.classList.remove('dragover');
            });
            
            input.addEventListener('drop', (e) => {
                e.preventDefault();
                input.classList.remove('dragover');
                
                const files = Array.from(e.dataTransfer.files);
                const fileInput = input.querySelector('input');
                const toolType = input.closest('.tool-card').dataset.tool;
                
                // Validate file types
                const validFiles = validateFileTypes(files, toolType);
                if (validFiles.length === 0) {
                    showNotification('No valid files dropped for that tool.', 'error');
                    return;
                }
                
                // Set files to input element (for single file inputs)
                if (!fileInput.multiple && validFiles.length > 0) {
                    const dt = new DataTransfer();
                    dt.items.add(validFiles[0]);
                    fileInput.files = dt.files;
                } else if (fileInput.multiple) {
                    const dt = new DataTransfer();
                    validFiles.forEach(file => dt.items.add(file));
                    fileInput.files = dt.files;
                }
                
                handleFileSelect(fileInput, toolType);
            });
        });
    }

    function validateFileTypes(files, toolType) {
        const acceptMap = {
            'word-to-pdf': ['.doc', '.docx'],
            'excel-to-pdf': ['.xls', '.xlsx'],
            'pdf-to-word': ['.pdf'],
            'pdf-to-excel': ['.pdf'],
            'jpg-to-pdf': ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp'],
            'merge-pdf': ['.pdf'],
            'split-pdf': ['.pdf'],
            'compress-pdf': ['.pdf'],
            'unlock-pdf': ['.pdf'],
            'lock-pdf': ['.pdf']
        };

        const acceptedExts = acceptMap[toolType] || [];
        return files.filter(file => {
            const ext = '.' + file.name.split('.').pop().toLowerCase();
            return acceptedExts.includes(ext);
        });
    }

    function handleFileSelect(input, toolType) {
        const files = Array.from(input.files);
        const toolCard = document.querySelector(`[data-tool="${toolType}"]`);
        const fileInfo = toolCard.querySelector('.file-info');
        const processBtn = toolCard.querySelector('.process-btn');
        const fileInputDisplay = toolCard.querySelector('.file-input span');
        
        if (files.length === 0) return;
        
        // Validate files
        const validFiles = validateFileTypes(files, toolType);
        if (validFiles.length === 0) {
            showNotification('Invalid file type! Please select the correct format.', 'error');
            return;
        }

        selectedFiles[toolType] = validFiles;
        
        if (toolType === 'merge-pdf') {
            updateMergeFileList(toolCard, validFiles);
        } else {
            updateFileInfo(fileInfo, fileInputDisplay, validFiles);
        }
        
        fileInfo.style.display = 'block';
        processBtn.disabled = false;
        processBtn.style.opacity = '1';
        processBtn.style.pointerEvents = 'auto';
    }

    function updateFileInfo(fileInfo, fileInputDisplay, files) {
        if (files.length === 1) {
            const file = files[0];
            const size = (file.size / 1024 / 1024).toFixed(2);
            fileInfo.innerHTML = `
                <div><strong>üìÅ ${file.name}</strong></div>
                <div>üìä Size: ${size} MB | Type: ${file.type || 'Unknown'}</div>
            `;
            fileInputDisplay.innerHTML = `‚úÖ ${file.name}`;
        } else {
            const totalSize = files.reduce((sum, file) => sum + file.size, 0) / 1024 / 1024;
            fileInfo.innerHTML = `
                <div><strong>üìÅ ${files.length} files selected</strong></div>
                <div>üìä Total size: ${totalSize.toFixed(2)} MB</div>
            `;
            fileInputDisplay.innerHTML = `‚úÖ ${files.length} files selected`;
        }
    }

    function updateMergeFileList(toolCard, files) {
        const fileList = toolCard.querySelector('.file-list');
        const fileInputDisplay = toolCard.querySelector('.file-input span');
        fileList.innerHTML = '';
        
        files.forEach((file, index) => {
            const fileItem = document.createElement('div');
            fileItem.className = 'file-item';
            const size = (file.size / 1024 / 1024).toFixed(2);
            fileItem.innerHTML = `
                <div>
                    <div><strong>üìÑ ${file.name}</strong></div>
                    <div style="font-size: 0.8em; color: #666;">${size} MB</div>
                </div>
                <button class="remove-btn" onclick="removeFile('merge-pdf', ${index})">Remove</button>
            `;
            fileList.appendChild(fileItem);
        });
        
        fileInputDisplay.innerHTML = `‚úÖ ${files.length} PDF files ready to merge`;
    }

    function removeFile(toolType, index) {
        if (selectedFiles[toolType]) {
            selectedFiles[toolType].splice(index, 1);
            const toolCard = document.querySelector(`[data-tool="${toolType}"]`);
            
            if (selectedFiles[toolType].length === 0) {
                const processBtn = toolCard.querySelector('.process-btn');
                const fileInfo = toolCard.querySelector('.file-info');
                processBtn.disabled = true;
                processBtn.style.opacity = '0.7';
                processBtn.style.pointerEvents = 'none';
                fileInfo.style.display = 'none';
            } else {
                updateMergeFileList(toolCard, selectedFiles[toolType]);
            }
        }
    }

    async function processFile(toolType) {
        const toolCard = document.querySelector(`[data-tool="${toolType}"]`);
        const files = selectedFiles[toolType];
        
        if (!files || files.length === 0) {
            showNotification('Please select files first!', 'error');
            return;
        }

        const isClientSide = toolCard.classList.contains('client-side');
        
        try {
            if (isClientSide) {
                await processClientSide(toolType, files, toolCard);
            } else {
                await processServerSide(toolType, files, toolCard);
            }
        } catch (error) {
            console.error('Processing error:', error);
            hideProgress(toolCard);
            showNotification(`Error: ${error.message}`, 'error');
        }
    }

    async function processClientSide(toolType, files, toolCard) {
        showProgress(toolCard, 'Processing on your device...');
        document.getElementById('cpuUsage').style.display = 'block';

        try {
            let resultBlob;
            switch (toolType) {
                case 'merge-pdf':
                    resultBlob = await mergePDFs(files, toolCard);
                    downloadBlob(resultBlob, 'merged.pdf');
                    showNotification('Merged PDF ready for download.', 'success');
                    break;
                case 'split-pdf':
                    await splitPDF(files[0], toolCard);
                    showNotification('Split PDFs downloaded.', 'success');
                    break;
                case 'compress-pdf':
                    resultBlob = await compressPDF(files[0], toolCard);
                    if (resultBlob) {
                        downloadBlob(resultBlob, appendSuffix(files[0].name, '-compressed.pdf'));
                        showNotification('Compressed PDF ready for download (best-effort).', 'success');
                    }
                    break;
                case 'unlock-pdf':
                    // Client-side unlocking (decryption) isn't reliably supported by pdf-lib.
                    showNotification('Client-side unlock not supported. Use server-side function.', 'error');
                    break;
                case 'lock-pdf':
                    showNotification('Client-side locking (adding password) is not implemented in this client example. Use server-side.', 'error');
                    break;
                case 'jpg-to-pdf':
                    resultBlob = await imagesToPDF(files, toolCard);
                    downloadBlob(resultBlob, 'images.pdf');
                    showNotification('PDF created from images.', 'success');
                    break;
                default:
                    showNotification('Tool not implemented client-side.', 'error');
            }
        } finally {
            hideProgress(toolCard);
            document.getElementById('cpuUsage').style.display = 'none';
        }
    }

    async function processServerSide(toolType, files, toolCard) {
        showProgress(toolCard, 'Uploading to serverless function...');
        const endpoint = `${API_BASE}/${toolType}`;
        const form = new FormData();
        files.forEach((file, i) => form.append('file' + i, file, file.name));

        // include password if unlock/lock
        if (toolType === 'unlock-pdf' || toolType === 'lock-pdf') {
            const pwd = toolCard.querySelector('.password-input') ? toolCard.querySelector('.password-input').value : '';
            form.append('password', pwd);
        }

        try {
            const resp = await fetch(endpoint, {
                method: 'POST',
                body: form
            });

            if (!resp.ok) {
                const text = await resp.text();
                throw new Error(text || `Server returned ${resp.status}`);
            }

            const contentType = resp.headers.get('Content-Type') || '';
            const filenameHeader = resp.headers.get('X-Filename') || '';
            const blob = await resp.blob();
            const name = filenameHeader || deriveFilenameForTool(toolType, files);
            downloadBlob(blob, name);
            showNotification('Server processing complete. File downloaded.', 'success');
        } catch (err) {
            console.error(err);
            showNotification('Server processing failed: ' + err.message, 'error');
        } finally {
            hideProgress(toolCard);
        }
    }

    // -------------------------
    // Client-side helpers
    // -------------------------
    async function mergePDFs(files, toolCard) {
        // Merge PDFs using pdf-lib
        showProgress(toolCard, 'Merging PDFs...');
        const mergedPdf = await PDFLib.PDFDocument.create();

        for (const file of files) {
            const arrayBuffer = await file.arrayBuffer();
            // Try to load. If encrypted, PDF-Lib may throw.
            let pdfDoc;
            try {
                pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);
            } catch (e) {
                console.warn('Failed to load one PDF (possibly encrypted):', file.name, e);
                throw new Error(`Cannot load ${file.name}. It may be password-protected.`);
            }
            const copiedPages = await mergedPdf.copyPages(pdfDoc, pdfDoc.getPageIndices());
            copiedPages.forEach(p => mergedPdf.addPage(p));
            // update progress (approx)
            updateProgress(toolCard, null, {increment: Math.floor(80 / files.length)});
        }

        const mergedBytes = await mergedPdf.save();
        updateProgress(toolCard, 100);
        return new Blob([mergedBytes], {type: 'application/pdf'});
    }

    async function splitPDF(file, toolCard) {
        showProgress(toolCard, 'Splitting PDF...');
        const arrayBuffer = await file.arrayBuffer();
        let pdfDoc;
        try {
            pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);
        } catch (e) {
            throw new Error('Unable to load PDF. It may be encrypted or corrupted.');
        }

        const totalPages = pdfDoc.getPageCount();
        for (let i = 0; i < totalPages; i++) {
            const newDoc = await PDFLib.PDFDocument.create();
            const [copied] = await newDoc.copyPages(pdfDoc, [i]);
            newDoc.addPage(copied);
            const bytes = await newDoc.save();
            const name = `${stripExtension(file.name)}_page_${i + 1}.pdf`;
            downloadBlob(new Blob([bytes], {type: 'application/pdf'}), name);
            updateProgress(toolCard, null, {increment: Math.floor(90 / totalPages)});
            // small pause to give browser breathing room on large PDFs
            await new Promise(r => setTimeout(r, 50));
        }
        updateProgress(toolCard, 100);
    }

    async function compressPDF(file, toolCard) {
        showProgress(toolCard, 'Compressing (best-effort)...');
        // Note: true PDF "compression" (re-encoding images, removing unused objects) requires specialized libraries.
        // We'll re-save with pdf-lib which sometimes yields smaller size; this is best-effort.
        const arrayBuffer = await file.arrayBuffer();
        let pdfDoc;
        try {
            pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);
        } catch (e) {
            throw new Error('Unable to load PDF for compression.');
        }
        // Basic strategy: copy pages to a new document to remove some overhead
        const out = await PDFLib.PDFDocument.create();
        const indices = pdfDoc.getPageIndices();
        const copied = await out.copyPages(pdfDoc, indices);
        copied.forEach(p => out.addPage(p));
        const newBytes = await out.save(); // pdf-lib's save is best-effort
        updateProgress(toolCard, 100);
        // If result is larger, return original and notify user
        if (newBytes.byteLength >= file.size) {
            showNotification('Compression had no effect; original file is smaller or same size.', 'info');
        }
        return new Blob([newBytes], {type: 'application/pdf'});
    }

    async function imagesToPDF(files, toolCard) {
        showProgress(toolCard, 'Creating PDF from images...');
        // Use jsPDF to create a PDF from images
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF(); // default A4 portrait
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            const dataUrl = await fileToDataURL(file);
            // create an image object to get dimensions
            const img = await loadImage(dataUrl);
            const pageWidth = doc.internal.pageSize.getWidth();
            const pageHeight = doc.internal.pageSize.getHeight();
            // calculate aspect fit
            const imgRatio = img.width / img.height;
            const pageRatio = pageWidth / pageHeight;
            let w, h;
            if (imgRatio > pageRatio) {
                w = pageWidth - 20;
                h = w / imgRatio;
            } else {
                h = pageHeight - 20;
                w = h * imgRatio;
            }
            const x = (pageWidth - w) / 2;
            const y = (pageHeight - h) / 2;
            if (i > 0) doc.addPage();
            // jsPDF addImage requires image type; dataUrl already includes type
            doc.addImage(dataUrl, 'JPEG', x, y, w, h);
            updateProgress(toolCard, null, {increment: Math.floor(90 / files.length)});
        }
        const pdfBlob = doc.output('blob');
        updateProgress(toolCard, 100);
        return pdfBlob;
    }

    // -------------------------
    // Utilities and UI helpers
    // -------------------------
    function showProgress(toolCard, message = 'Processing...') {
        const progressBar = toolCard.querySelector('.progress-bar');
        const fill = toolCard.querySelector('.progress-fill');
        progressBar.style.display = 'block';
        fill.style.width = '0%';
        fill.dataset.current = 0;
        if (!toolCard._progressInterval) {
            toolCard._progressInterval = setInterval(() => {
                let cur = parseInt(fill.dataset.current || '0', 10);
                if (cur < 10) {
                    cur += 1;
                } else if (cur < 70) {
                    cur += 2;
                } else if (cur < 95) {
                    cur += 1;
                }
                if (cur > 99) cur = 99;
                fill.style.width = cur + '%';
                fill.dataset.current = String(cur);
            }, 400);
        }
        // set small status notification (not blocking)
        showNotification(message, 'info', 2000);
    }

    function updateProgress(toolCard, absolutePercent = null, opts = {}) {
        const fill = toolCard.querySelector('.progress-fill');
        if (!fill) return;
        if (absolutePercent !== null) {
            fill.style.width = absolutePercent + '%';
            fill.dataset.current = String(absolutePercent);
        } else if (opts.increment) {
            let cur = parseInt(fill.dataset.current || '0', 10);
            cur = Math.min(99, cur + opts.increment);
            fill.style.width = cur + '%';
            fill.dataset.current = String(cur);
        }
    }

    function hideProgress(toolCard) {
        const progressBar = toolCard.querySelector('.progress-bar');
        const fill = toolCard.querySelector('.progress-fill');
        if (toolCard._progressInterval) {
            clearInterval(toolCard._progressInterval);
            toolCard._progressInterval = null;
        }
        if (fill) {
            fill.style.width = '100%';
            fill.dataset.current = '100';
        }
        setTimeout(() => {
            if (progressBar) progressBar.style.display = 'none';
            if (fill) fill.style.width = '0%';
        }, 600);
    }

    function showNotification(msg, type = 'info', autoHideMs = 3000) {
        const n = document.createElement('div');
        n.className = `notification ${type}`;
        n.innerHTML = `<strong>${msg}</strong>`;
        document.body.appendChild(n);
        requestAnimationFrame(() => n.classList.add('show'));
        if (autoHideMs) {
            setTimeout(() => {
                n.classList.remove('show');
                setTimeout(() => n.remove(), 300);
            }, autoHideMs);
        }
    }

    function downloadBlob(blob, filename) {
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        setTimeout(() => {
            URL.revokeObjectURL(link.href);
            link.remove();
        }, 5000);
    }

    function appendSuffix(name, suffix) {
        const idx = name.lastIndexOf('.');
        if (idx === -1) return name + suffix;
        return name.slice(0, idx) + suffix;
    }

    function stripExtension(name) {
        const idx = name.lastIndexOf('.');
        if (idx === -1) return name;
        return name.slice(0, idx);
    }

    function deriveFilenameForTool(toolType, files) {
        switch (toolType) {
            case 'word-to-pdf':
                return stripExtension(files[0].name) + '.pdf';
            case 'excel-to-pdf':
                return stripExtension(files[0].name) + '.pdf';
            case 'pdf-to-word':
                return stripExtension(files[0].name) + '.docx';
            case 'pdf-to-excel':
                return stripExtension(files[0].name) + '.xlsx';
            default:
                return 'output.pdf';
        }
    }

    function fileToDataURL(file) {
        return new Promise((res, rej) => {
            const reader = new FileReader();
            reader.onload = () => res(reader.result);
            reader.onerror = rej;
            reader.readAsDataURL(file);
        });
    }

    function loadImage(dataUrl) {
        return new Promise((res, rej) => {
            const img = new Image();
            img.onload = () => res(img);
            img.onerror = rej;
            img.src = dataUrl;
        });
    }

    // small helper to format bytes ‚Äî not used widely but handy for future
    function bytesToSize(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    // Expose some functions globally for debug/testing
    window._pdfTools = {
        selectedFiles,
        mergePDFs,
        splitPDF,
        compressPDF,
        imagesToPDF
    };
</script>
